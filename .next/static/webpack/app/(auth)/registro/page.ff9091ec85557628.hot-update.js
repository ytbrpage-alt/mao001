"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(auth)/registro/page",{

/***/ "(app-pages-browser)/./src/lib/utils/masks.ts":
/*!********************************!*\
  !*** ./src/lib/utils/masks.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MASKS: function() { return /* binding */ MASKS; },\n/* harmony export */   applyMask: function() { return /* binding */ applyMask; },\n/* harmony export */   formatCEP: function() { return /* binding */ formatCEP; },\n/* harmony export */   formatCPF: function() { return /* binding */ formatCPF; },\n/* harmony export */   formatName: function() { return /* binding */ formatName; },\n/* harmony export */   formatPhone: function() { return /* binding */ formatPhone; },\n/* harmony export */   formatRG: function() { return /* binding */ formatRG; },\n/* harmony export */   maskCEP: function() { return /* binding */ maskCEP; },\n/* harmony export */   maskCPF: function() { return /* binding */ maskCPF; },\n/* harmony export */   maskPhone: function() { return /* binding */ maskPhone; },\n/* harmony export */   removeMask: function() { return /* binding */ removeMask; },\n/* harmony export */   validateCEP: function() { return /* binding */ validateCEP; },\n/* harmony export */   validateCPF: function() { return /* binding */ validateCPF; },\n/* harmony export */   validateName: function() { return /* binding */ validateName; },\n/* harmony export */   validatePhone: function() { return /* binding */ validatePhone; }\n/* harmony export */ });\n// src/lib/utils/masks.ts\n// Input masks and formatters for Brazilian documents\n/**\r\n * Apply mask to a string value\r\n */ function applyMask(value, mask) {\n    let result = \"\";\n    let valueIndex = 0;\n    const cleanValue = value.replace(/\\D/g, \"\");\n    for(let i = 0; i < mask.length && valueIndex < cleanValue.length; i++){\n        if (mask[i] === \"9\") {\n            result += cleanValue[valueIndex];\n            valueIndex++;\n        } else {\n            result += mask[i];\n        }\n    }\n    return result;\n}\n/**\r\n * Remove mask from value, keeping only digits\r\n */ function removeMask(value) {\n    return value.replace(/\\D/g, \"\");\n}\n// Mask patterns\nconst MASKS = {\n    CPF: \"999.999.999-99\",\n    RG: \"99.999.999-9\",\n    PHONE: \"(99) 99999-9999\",\n    PHONE_FIXED: \"(99) 9999-9999\",\n    CEP: \"99999-999\",\n    DATE: \"99/99/9999\",\n    TIME: \"99:99\",\n    CREDIT_CARD: \"9999 9999 9999 9999\",\n    CNPJ: \"99.999.999/9999-99\"\n};\n/**\r\n * Format CPF: 000.000.000-00\r\n */ function formatCPF(value) {\n    return applyMask(value, MASKS.CPF);\n}\n/**\r\n * Format Phone: (00) 00000-0000 or (00) 0000-0000\r\n */ function formatPhone(value) {\n    const digits = removeMask(value);\n    // If more than 10 digits, use mobile format\n    return applyMask(value, digits.length > 10 ? MASKS.PHONE : MASKS.PHONE_FIXED);\n}\n/**\r\n * Format CEP: 00000-000\r\n */ function formatCEP(value) {\n    return applyMask(value, MASKS.CEP);\n}\n/**\r\n * Format RG: 00.000.000-0\r\n */ function formatRG(value) {\n    return applyMask(value, MASKS.RG);\n}\n/**\r\n * Validate CPF algorithmically\r\n */ function validateCPF(cpf) {\n    const digits = removeMask(cpf);\n    if (digits.length !== 11) return false;\n    if (/^(\\d)\\1{10}$/.test(digits)) return false; // All same digits\n    // First verification digit\n    let sum = 0;\n    for(let i = 0; i < 9; i++){\n        sum += parseInt(digits[i]) * (10 - i);\n    }\n    let remainder = sum * 10 % 11;\n    if (remainder === 10 || remainder === 11) remainder = 0;\n    if (remainder !== parseInt(digits[9])) return false;\n    // Second verification digit\n    sum = 0;\n    for(let i = 0; i < 10; i++){\n        sum += parseInt(digits[i]) * (11 - i);\n    }\n    remainder = sum * 10 % 11;\n    if (remainder === 10 || remainder === 11) remainder = 0;\n    if (remainder !== parseInt(digits[10])) return false;\n    return true;\n}\n/**\r\n * Validate phone number\r\n */ function validatePhone(phone) {\n    const digits = removeMask(phone);\n    return digits.length >= 10 && digits.length <= 11;\n}\n/**\r\n * Validate CEP\r\n */ function validateCEP(cep) {\n    const digits = removeMask(cep);\n    return digits.length === 8;\n}\n/**\r\n * Validate name (at least 2 words, only letters)\r\n */ function validateName(name) {\n    const trimmed = name.trim();\n    const words = trimmed.split(/\\s+/);\n    if (words.length < 2) return false;\n    // Each word should have at least 2 characters\n    return words.every((word)=>word.length >= 2 && /^[a-zA-ZÀ-ÿ]+$/.test(word));\n}\n/**\r\n * Format name (capitalize each word)\r\n */ function formatName(name) {\n    const particles = [\n        \"de\",\n        \"da\",\n        \"do\",\n        \"das\",\n        \"dos\",\n        \"e\"\n    ];\n    return name.toLowerCase().split(/\\s+/).map((word, index)=>{\n        if (index > 0 && particles.includes(word)) {\n            return word;\n        }\n        return word.charAt(0).toUpperCase() + word.slice(1);\n    }).join(\" \");\n}\n// Aliases for compatibility\nconst maskCPF = formatCPF;\nconst maskPhone = formatPhone;\nconst maskCEP = formatCEP;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMvbWFza3MudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLHFEQUFxRDtBQUVyRDs7Q0FFQyxHQUNNLFNBQVNBLFVBQVVDLEtBQWEsRUFBRUMsSUFBWTtJQUNqRCxJQUFJQyxTQUFTO0lBQ2IsSUFBSUMsYUFBYTtJQUNqQixNQUFNQyxhQUFhSixNQUFNSyxPQUFPLENBQUMsT0FBTztJQUV4QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUwsS0FBS00sTUFBTSxJQUFJSixhQUFhQyxXQUFXRyxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSUwsSUFBSSxDQUFDSyxFQUFFLEtBQUssS0FBSztZQUNqQkosVUFBVUUsVUFBVSxDQUFDRCxXQUFXO1lBQ2hDQTtRQUNKLE9BQU87WUFDSEQsVUFBVUQsSUFBSSxDQUFDSyxFQUFFO1FBQ3JCO0lBQ0o7SUFFQSxPQUFPSjtBQUNYO0FBRUE7O0NBRUMsR0FDTSxTQUFTTSxXQUFXUixLQUFhO0lBQ3BDLE9BQU9BLE1BQU1LLE9BQU8sQ0FBQyxPQUFPO0FBQ2hDO0FBRUEsZ0JBQWdCO0FBQ1QsTUFBTUksUUFBUTtJQUNqQkMsS0FBSztJQUNMQyxJQUFJO0lBQ0pDLE9BQU87SUFDUEMsYUFBYTtJQUNiQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxhQUFhO0lBQ2JDLE1BQU07QUFDVixFQUFFO0FBRUY7O0NBRUMsR0FDTSxTQUFTQyxVQUFVbkIsS0FBYTtJQUNuQyxPQUFPRCxVQUFVQyxPQUFPUyxNQUFNQyxHQUFHO0FBQ3JDO0FBRUE7O0NBRUMsR0FDTSxTQUFTVSxZQUFZcEIsS0FBYTtJQUNyQyxNQUFNcUIsU0FBU2IsV0FBV1I7SUFDMUIsNENBQTRDO0lBQzVDLE9BQU9ELFVBQVVDLE9BQU9xQixPQUFPZCxNQUFNLEdBQUcsS0FBS0UsTUFBTUcsS0FBSyxHQUFHSCxNQUFNSSxXQUFXO0FBQ2hGO0FBRUE7O0NBRUMsR0FDTSxTQUFTUyxVQUFVdEIsS0FBYTtJQUNuQyxPQUFPRCxVQUFVQyxPQUFPUyxNQUFNSyxHQUFHO0FBQ3JDO0FBRUE7O0NBRUMsR0FDTSxTQUFTUyxTQUFTdkIsS0FBYTtJQUNsQyxPQUFPRCxVQUFVQyxPQUFPUyxNQUFNRSxFQUFFO0FBQ3BDO0FBRUE7O0NBRUMsR0FDTSxTQUFTYSxZQUFZQyxHQUFXO0lBQ25DLE1BQU1KLFNBQVNiLFdBQVdpQjtJQUUxQixJQUFJSixPQUFPZCxNQUFNLEtBQUssSUFBSSxPQUFPO0lBQ2pDLElBQUksZUFBZW1CLElBQUksQ0FBQ0wsU0FBUyxPQUFPLE9BQU8sa0JBQWtCO0lBRWpFLDJCQUEyQjtJQUMzQixJQUFJTSxNQUFNO0lBQ1YsSUFBSyxJQUFJckIsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7UUFDeEJxQixPQUFPQyxTQUFTUCxNQUFNLENBQUNmLEVBQUUsSUFBSyxNQUFLQSxDQUFBQTtJQUN2QztJQUNBLElBQUl1QixZQUFZLE1BQU8sS0FBTTtJQUM3QixJQUFJQSxjQUFjLE1BQU1BLGNBQWMsSUFBSUEsWUFBWTtJQUN0RCxJQUFJQSxjQUFjRCxTQUFTUCxNQUFNLENBQUMsRUFBRSxHQUFHLE9BQU87SUFFOUMsNEJBQTRCO0lBQzVCTSxNQUFNO0lBQ04sSUFBSyxJQUFJckIsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7UUFDekJxQixPQUFPQyxTQUFTUCxNQUFNLENBQUNmLEVBQUUsSUFBSyxNQUFLQSxDQUFBQTtJQUN2QztJQUNBdUIsWUFBWSxNQUFPLEtBQU07SUFDekIsSUFBSUEsY0FBYyxNQUFNQSxjQUFjLElBQUlBLFlBQVk7SUFDdEQsSUFBSUEsY0FBY0QsU0FBU1AsTUFBTSxDQUFDLEdBQUcsR0FBRyxPQUFPO0lBRS9DLE9BQU87QUFDWDtBQUVBOztDQUVDLEdBQ00sU0FBU1MsY0FBY0MsS0FBYTtJQUN2QyxNQUFNVixTQUFTYixXQUFXdUI7SUFDMUIsT0FBT1YsT0FBT2QsTUFBTSxJQUFJLE1BQU1jLE9BQU9kLE1BQU0sSUFBSTtBQUNuRDtBQUVBOztDQUVDLEdBQ00sU0FBU3lCLFlBQVlDLEdBQVc7SUFDbkMsTUFBTVosU0FBU2IsV0FBV3lCO0lBQzFCLE9BQU9aLE9BQU9kLE1BQU0sS0FBSztBQUM3QjtBQUVBOztDQUVDLEdBQ00sU0FBUzJCLGFBQWFDLElBQVk7SUFDckMsTUFBTUMsVUFBVUQsS0FBS0UsSUFBSTtJQUN6QixNQUFNQyxRQUFRRixRQUFRRyxLQUFLLENBQUM7SUFDNUIsSUFBSUQsTUFBTS9CLE1BQU0sR0FBRyxHQUFHLE9BQU87SUFDN0IsOENBQThDO0lBQzlDLE9BQU8rQixNQUFNRSxLQUFLLENBQUNDLENBQUFBLE9BQVFBLEtBQUtsQyxNQUFNLElBQUksS0FBSyxpQkFBaUJtQixJQUFJLENBQUNlO0FBQ3pFO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxXQUFXUCxJQUFZO0lBQ25DLE1BQU1RLFlBQVk7UUFBQztRQUFNO1FBQU07UUFBTTtRQUFPO1FBQU87S0FBSTtJQUN2RCxPQUFPUixLQUNGUyxXQUFXLEdBQ1hMLEtBQUssQ0FBQyxPQUNOTSxHQUFHLENBQUMsQ0FBQ0osTUFBTUs7UUFDUixJQUFJQSxRQUFRLEtBQUtILFVBQVVJLFFBQVEsQ0FBQ04sT0FBTztZQUN2QyxPQUFPQTtRQUNYO1FBQ0EsT0FBT0EsS0FBS08sTUFBTSxDQUFDLEdBQUdDLFdBQVcsS0FBS1IsS0FBS1MsS0FBSyxDQUFDO0lBQ3JELEdBQ0NDLElBQUksQ0FBQztBQUNkO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1DLFVBQVVqQyxVQUFVO0FBQzFCLE1BQU1rQyxZQUFZakMsWUFBWTtBQUM5QixNQUFNa0MsVUFBVWhDLFVBQVUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi91dGlscy9tYXNrcy50cz9jYjI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9saWIvdXRpbHMvbWFza3MudHNcclxuLy8gSW5wdXQgbWFza3MgYW5kIGZvcm1hdHRlcnMgZm9yIEJyYXppbGlhbiBkb2N1bWVudHNcclxuXHJcbi8qKlxyXG4gKiBBcHBseSBtYXNrIHRvIGEgc3RyaW5nIHZhbHVlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlNYXNrKHZhbHVlOiBzdHJpbmcsIG1hc2s6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICBsZXQgdmFsdWVJbmRleCA9IDA7XHJcbiAgICBjb25zdCBjbGVhblZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxEL2csICcnKTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hc2subGVuZ3RoICYmIHZhbHVlSW5kZXggPCBjbGVhblZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKG1hc2tbaV0gPT09ICc5Jykge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gY2xlYW5WYWx1ZVt2YWx1ZUluZGV4XTtcclxuICAgICAgICAgICAgdmFsdWVJbmRleCsrO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBtYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIG1hc2sgZnJvbSB2YWx1ZSwga2VlcGluZyBvbmx5IGRpZ2l0c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU1hc2sodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXFxEL2csICcnKTtcclxufVxyXG5cclxuLy8gTWFzayBwYXR0ZXJuc1xyXG5leHBvcnQgY29uc3QgTUFTS1MgPSB7XHJcbiAgICBDUEY6ICc5OTkuOTk5Ljk5OS05OScsXHJcbiAgICBSRzogJzk5Ljk5OS45OTktOScsXHJcbiAgICBQSE9ORTogJyg5OSkgOTk5OTktOTk5OScsXHJcbiAgICBQSE9ORV9GSVhFRDogJyg5OSkgOTk5OS05OTk5JyxcclxuICAgIENFUDogJzk5OTk5LTk5OScsXHJcbiAgICBEQVRFOiAnOTkvOTkvOTk5OScsXHJcbiAgICBUSU1FOiAnOTk6OTknLFxyXG4gICAgQ1JFRElUX0NBUkQ6ICc5OTk5IDk5OTkgOTk5OSA5OTk5JyxcclxuICAgIENOUEo6ICc5OS45OTkuOTk5Lzk5OTktOTknLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBDUEY6IDAwMC4wMDAuMDAwLTAwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Q1BGKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGFwcGx5TWFzayh2YWx1ZSwgTUFTS1MuQ1BGKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBQaG9uZTogKDAwKSAwMDAwMC0wMDAwIG9yICgwMCkgMDAwMC0wMDAwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UGhvbmUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBkaWdpdHMgPSByZW1vdmVNYXNrKHZhbHVlKTtcclxuICAgIC8vIElmIG1vcmUgdGhhbiAxMCBkaWdpdHMsIHVzZSBtb2JpbGUgZm9ybWF0XHJcbiAgICByZXR1cm4gYXBwbHlNYXNrKHZhbHVlLCBkaWdpdHMubGVuZ3RoID4gMTAgPyBNQVNLUy5QSE9ORSA6IE1BU0tTLlBIT05FX0ZJWEVEKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBDRVA6IDAwMDAwLTAwMFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdENFUCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBhcHBseU1hc2sodmFsdWUsIE1BU0tTLkNFUCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgUkc6IDAwLjAwMC4wMDAtMFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFJHKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGFwcGx5TWFzayh2YWx1ZSwgTUFTS1MuUkcpO1xyXG59XHJcblxyXG4vKipcclxuICogVmFsaWRhdGUgQ1BGIGFsZ29yaXRobWljYWxseVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ1BGKGNwZjogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBkaWdpdHMgPSByZW1vdmVNYXNrKGNwZik7XHJcblxyXG4gICAgaWYgKGRpZ2l0cy5sZW5ndGggIT09IDExKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoL14oXFxkKVxcMXsxMH0kLy50ZXN0KGRpZ2l0cykpIHJldHVybiBmYWxzZTsgLy8gQWxsIHNhbWUgZGlnaXRzXHJcblxyXG4gICAgLy8gRmlyc3QgdmVyaWZpY2F0aW9uIGRpZ2l0XHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XHJcbiAgICAgICAgc3VtICs9IHBhcnNlSW50KGRpZ2l0c1tpXSkgKiAoMTAgLSBpKTtcclxuICAgIH1cclxuICAgIGxldCByZW1haW5kZXIgPSAoc3VtICogMTApICUgMTE7XHJcbiAgICBpZiAocmVtYWluZGVyID09PSAxMCB8fCByZW1haW5kZXIgPT09IDExKSByZW1haW5kZXIgPSAwO1xyXG4gICAgaWYgKHJlbWFpbmRlciAhPT0gcGFyc2VJbnQoZGlnaXRzWzldKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIC8vIFNlY29uZCB2ZXJpZmljYXRpb24gZGlnaXRcclxuICAgIHN1bSA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcclxuICAgICAgICBzdW0gKz0gcGFyc2VJbnQoZGlnaXRzW2ldKSAqICgxMSAtIGkpO1xyXG4gICAgfVxyXG4gICAgcmVtYWluZGVyID0gKHN1bSAqIDEwKSAlIDExO1xyXG4gICAgaWYgKHJlbWFpbmRlciA9PT0gMTAgfHwgcmVtYWluZGVyID09PSAxMSkgcmVtYWluZGVyID0gMDtcclxuICAgIGlmIChyZW1haW5kZXIgIT09IHBhcnNlSW50KGRpZ2l0c1sxMF0pKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSBwaG9uZSBudW1iZXJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBob25lKHBob25lOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGRpZ2l0cyA9IHJlbW92ZU1hc2socGhvbmUpO1xyXG4gICAgcmV0dXJuIGRpZ2l0cy5sZW5ndGggPj0gMTAgJiYgZGlnaXRzLmxlbmd0aCA8PSAxMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIENFUFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQ0VQKGNlcDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBkaWdpdHMgPSByZW1vdmVNYXNrKGNlcCk7XHJcbiAgICByZXR1cm4gZGlnaXRzLmxlbmd0aCA9PT0gODtcclxufVxyXG5cclxuLyoqXHJcbiAqIFZhbGlkYXRlIG5hbWUgKGF0IGxlYXN0IDIgd29yZHMsIG9ubHkgbGV0dGVycylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU5hbWUobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCB0cmltbWVkID0gbmFtZS50cmltKCk7XHJcbiAgICBjb25zdCB3b3JkcyA9IHRyaW1tZWQuc3BsaXQoL1xccysvKTtcclxuICAgIGlmICh3b3Jkcy5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XHJcbiAgICAvLyBFYWNoIHdvcmQgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzXHJcbiAgICByZXR1cm4gd29yZHMuZXZlcnkod29yZCA9PiB3b3JkLmxlbmd0aCA+PSAyICYmIC9eW2EtekEtWsOALcO/XSskLy50ZXN0KHdvcmQpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZvcm1hdCBuYW1lIChjYXBpdGFsaXplIGVhY2ggd29yZClcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBwYXJ0aWNsZXMgPSBbJ2RlJywgJ2RhJywgJ2RvJywgJ2RhcycsICdkb3MnLCAnZSddO1xyXG4gICAgcmV0dXJuIG5hbWVcclxuICAgICAgICAudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIC5zcGxpdCgvXFxzKy8pXHJcbiAgICAgICAgLm1hcCgod29yZCwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiBwYXJ0aWNsZXMuaW5jbHVkZXMod29yZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3b3JkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5qb2luKCcgJyk7XHJcbn1cclxuXHJcbi8vIEFsaWFzZXMgZm9yIGNvbXBhdGliaWxpdHlcclxuZXhwb3J0IGNvbnN0IG1hc2tDUEYgPSBmb3JtYXRDUEY7XHJcbmV4cG9ydCBjb25zdCBtYXNrUGhvbmUgPSBmb3JtYXRQaG9uZTtcclxuZXhwb3J0IGNvbnN0IG1hc2tDRVAgPSBmb3JtYXRDRVA7XHJcblxyXG4iXSwibmFtZXMiOlsiYXBwbHlNYXNrIiwidmFsdWUiLCJtYXNrIiwicmVzdWx0IiwidmFsdWVJbmRleCIsImNsZWFuVmFsdWUiLCJyZXBsYWNlIiwiaSIsImxlbmd0aCIsInJlbW92ZU1hc2siLCJNQVNLUyIsIkNQRiIsIlJHIiwiUEhPTkUiLCJQSE9ORV9GSVhFRCIsIkNFUCIsIkRBVEUiLCJUSU1FIiwiQ1JFRElUX0NBUkQiLCJDTlBKIiwiZm9ybWF0Q1BGIiwiZm9ybWF0UGhvbmUiLCJkaWdpdHMiLCJmb3JtYXRDRVAiLCJmb3JtYXRSRyIsInZhbGlkYXRlQ1BGIiwiY3BmIiwidGVzdCIsInN1bSIsInBhcnNlSW50IiwicmVtYWluZGVyIiwidmFsaWRhdGVQaG9uZSIsInBob25lIiwidmFsaWRhdGVDRVAiLCJjZXAiLCJ2YWxpZGF0ZU5hbWUiLCJuYW1lIiwidHJpbW1lZCIsInRyaW0iLCJ3b3JkcyIsInNwbGl0IiwiZXZlcnkiLCJ3b3JkIiwiZm9ybWF0TmFtZSIsInBhcnRpY2xlcyIsInRvTG93ZXJDYXNlIiwibWFwIiwiaW5kZXgiLCJpbmNsdWRlcyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJqb2luIiwibWFza0NQRiIsIm1hc2tQaG9uZSIsIm1hc2tDRVAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils/masks.ts\n"));

/***/ })

});